#!/usr/bin/python3
from subprocess import check_output,check_call,Popen,PIPE,DEVNULL
from os import path
from shlex import split
import argparse
from sys import argv
from os import environ,getcwd
import neovim
import logging
"""
Cmds to do stuff.
Fish shell syntax.
"""
homedirexcludelistfilename=str(environ.get('HOME'))+"/.gitsuperpushpull2tmrlexcludeliste"
gitaddremotecmd='git remote add tmrl tmrl:'
branchcmd='git branch'
remotecmd='git remote'
mastercheckoutcmd='git checkout master'
pushcmdbase='git push -q tmrl'
dotfpushcmd='dotf push -q tmrl dev'
pullcmdbase='git pull -q tmrl'
dotfpullcmd='dotf pull tmrl dev'
#LOGLEVEL=logging.WARNING
#LOGLEVEL=logging.DEBUG
LOGLEVEL=logging.INFO
SHELLCMD_BASE = [ 'fish', '-c' ]

try:
    log=logging.getLogger('root')
    log.setLevel(LOGLEVEL)
    handler=logging.StreamHandler()
    ## level for this handler
    handler.setLevel(LOGLEVEL)
    handler.setFormatter(logging.Formatter('%(asctime)s %(levelname)s %(funcName)s: %(message)s'))
    log.addHandler(handler)
except KeyboardInterrupt as e: raise e
except Exception as e: logging.info(e)



log.debug(homedirexcludelistfilename)


def askcontinue():
  if input('continue? (y/n) :') == 'y':
    return True
  else:
    return false

def askcmd(cmd):
  if input('do? '+str(cmd))=='y':
    check_call(cmd)


def check_shell_call_in_dir(cmdstring,directorystring):
    cmd = SHELLCMD_BASE + ['cd '+directory+';and '+string]
    check_call(cmd)

def clone2tmrl(i):
  try: 
    ask_rsync(i)
  except:
    ask_create_remotepath(i)
    ask_rsync(i)

def exclude(liste,excludelistfilename):
  """
  This removes the lines that are contained in excludelistfilename from the list that will be processed.
  Exact match is needed. Path names have to be absolute and "normpath".
  """
  log.debug('')
  f=open(excludelistfilename,'rb')
  removeliste=f.read().decode().split()
  f.close()
  log.debug(removeliste)
  for i in removeliste:
      for j in liste:
          if j==i:
              log.info('excluding: '+ j)
              liste.remove(j)
  return liste

def append2excludefile(string,excludelistfilename):
  log.debug('')
  f=open(excludelistfilename,'at')
  f.write(path.abspath(string)+'/.git\n')
  f.close()


def fix_stuff(dir):
  """
  Interactively try to fix the faulty condition that leads to push/pull to tmrl failure.
  Assumes the remote config is ok.
  Uses the clone2tmrl command, because the main failure reason is that there is no repo on the remote side.
  """
  log.debug('trying to get the pushpull working...')
  log.debug('remote config already checked.')
  log.debug('remaining reasons: remote git not ok, conflics, ...')
  ask_terminal(str(dir))
  clone2tmrl(dir)

def check_pushpull(i):
  """
  Tries to push to tmrl first, then tries to pull and push to/from tmrl.
  """
  log.debug('')
  try:
    for j in get_branches(i):
      try:
        log.log(19,'doing push for branch '+j+' in dir '+i)
        pushcmd=pushcmdbase+' '+j
        log.log(19,pushcmd)
        check_call(['fish','-c','cd '+ i +';and '+pushcmd],stderr=DEVNULL)
      except KeyboardInterrupt: raise
      except:
        log.info('push failed for branch "'+j+'", doing pull in dir: '+i)
        try:
          pullcmd=pullcmdbase+' '+j
          log.log(19,pullcmd)
          out=check_output(['fish','-c','cd '+ i +';and '+pullcmd])
          log.log(19,'doing push: '+i)
          pushcmd=pushcmdbase+' '+j
          log.log(19,pushcmd)
          out=check_output(['fish','-c','cd '+ i +';and '+pushcmd])
        except KeyboardInterrupt: raise
        except:
          log.error(out)
          raise
    return True
  except KeyboardInterrupt: raise
  except:
    return False



def dotfpushpull():
  """
  Tries to push dotfiles to tmrl first, then tries to pull and push to/from tmrl.
  """
  log.debug('')
  try:
    log.log(19,'doing push: dotfiles.')
    check_call(['fish','-c',dotfpushcmd],stderr=DEVNULL)
  except KeyboardInterrupt: raise
  except:
    log.info('push failed, doing pull: dotfiles.')
    try:
      if check_call(['fish','-c',dotfpullcmd],stderr=DEVNULL):
        log.log(19,'doing push: dotfiles.')
        check_call(['fish','-c',dotfpushcmd],stderr=DEVNULL)
    except KeyboardInterrupt: raise
    except:
        raise

def check_and_fix_some_stuff(i):
  """
  Checks the git remote entry and offer adding one or exclude the repo.
  If returns true, allright.
  """
  log.debug('')
  ### first check if repo is local
  if not path.exists(i):
    print('detected git dir that exists only on remote.')
    inp = input('offer fix ? y/n/p , p meens exclude. :')
    if inp == 'y':
      fix_stuff(i)
      return check_and_fix_some_stuff(i)
    elif inp == 'n':
      return False
    elif inp == 'p':
      append2excludefile(i,homedirexcludelistfilename)
      log.info("added to excludeliste: "+str(i))
      return False
  ## dir is there , go on
  o=check_output(['fish','-c','cd '+ i +';and '+remotecmd]).decode().strip()
  if o.find('tmrl') is -1:
    cmdaddremotestr=gitaddremotecmd+i
    inp = input('do? answer y/n/p , p meens exclude. :'+str(cmdaddremotestr))
    if inp == 'y':
      try:
        addremote(i)
      except KeyboardInterrupt: raise
      except:
        fix_stuff(i)
        return check_and_fix_some_stuff(i)
    elif inp == 'n':
      return False
    elif inp == 'p':
      append2excludefile(i,homedirexcludelistfilename)
      log.info("added to excludeliste: "+str(i))
      return False
  else:
      return True

def ask_terminal(i):
  """
  offer some rsync cmd that copies the repo to tmrl
  """
  log.debug('')
  if input('want terminal to fix? (y/n):')=='y':
    path=environ['NVIM_LISTEN_ADDRESS']
    nvim = neovim.attach('socket',path=path)
    win_id=nvim.call('win_getid')
    nvim.command('tabnew')
    log.debug('fish -C cd '+i)
    nvim.call('termopen',['fish', '-C', 'cd '+i])
    nvim.command('tnoremap <buffer> <C-q> <C-\><C-n>:q<CR>:call win_gotoid('+str(win_id)+')<CR>i')
    input('done? press enter or so')


def ask_rsync(i):
  """
  offer some rsync cmd that copies the repo to tmrl
  """
  log.debug('')
  rsynccmdstr='rsync -auiv '+path.abspath(i)+' tmrl:'+path.split(path.abspath(i))[0]+'/'
  if input('do cmd: '+rsynccmdstr+' if yes , type uppercase yes:') == 'YES':
    check_call(['fish','-c',rsynccmdstr],stderr=DEVNULL)

def ask_create_remotepath(i):
    """
    Offer cmd to create remotepath.
    """
    cmdstr='ssh tmrl mkdir -p '+path.split(path.abspath(i))[0]
    if input('do cmd: '+cmdstr):
      check_call(['fish','-c',cmdstr],stderr=DEVNULL)


def ask_exclude(i):
    log.debug('')
    inp = input('exclude '+str(i) +' ? (y/n) ')
    if inp == 'y':
      append2excludefile(i,homedirexcludelistfilename)
      log.info('excluding: '+ i)
      return True
    else:
      return False

def addremote(i):
  """
  Add the remote tmrl to the the specified repo.
  """
  log.debug('')
  cmdaddremotestr=gitaddremotecmd+i
  check_call(['fish','-c','cd '+ i +';and '+cmdaddremotestr],stderr=DEVNULL)

def check_branch(i):
  o=check_output(['fish','-c','cd '+ i +';and '+branchcmd]).decode().strip()
  if o.find('HEAD losgel√∂st') is not -1:
    if o.find('master') is not -1:
      log.info('doing master checkout: '+i)
      check_call(['fish','-c','cd '+ i +';and '+mastercheckoutcmd],stderr=DEVNULL)
  o=check_output(['fish','-c','cd '+ i +';and '+branchcmd]).decode().strip()
  if o.find('* master') is not -1:
        return True
  else:
      return False

def get_branches(i):
  '''
  returns list of branches in dir i.
  '''
  log.debug('')
  ll=[]
  l = check_output(['fish','-c','cd '+ i +';and '+branchcmd]).decode().splitlines()
  for i in l:
      if i.find('* (HEAD ') is not -1:
          pass
          ##  no branch to push
          ##  if no branch, no need to push
      else:
          ll.append(i.strip('*').strip())
      
  return ll

def calendarsync():
  log.debug('')
  """
  sync pimdir
  """
  log.debug('')
  check_call(['fish','-c','calendarsync'],stderr=DEVNULL,stdout=DEVNULL)


def generate_liste(quick=None):
  log.debug('')
  cmdbase=['fish', '-c']
  cmdbase_remote=['ssh', 'tmrl', 'fish', '-c']
  findcmdbase = 'find'
  grepcmd = "grep -E '/[.]git$'"
  cwd=getcwd()
  if not quick is None:
      findtimeparam='-mtime -'+n
      n=quick
      cmd1=cmdbase+[findcmdbase+findtimeparam+'|'+grepcmd]
      cmd2=cmdbase_remote+[findcmdbase+findtimeparam+'|'+grepcmd]
      log.info(cmd1)
      log.info(cmd2)
      print('processing modified stuff, during last '+str(n)+' * 24 h')
  else:
      cmd1=cmdbase+[findcmdbase+'|'+grepcmd]
      cmd2=cmdbase_remote+[findcmdbase+'|'+grepcmd]
      log.info(cmd1)
      log.info(cmd2)
  liste1=[]
  liste2=[]
  try :
      p1=Popen(cmd1, stdout=PIPE, universal_newlines=False)
      p2=Popen(cmd2, stdout=PIPE, universal_newlines=False)
      liste1=p1.stdout.read().decode(errors='replace').split()
      for j in liste1:
          log.debug(j)
      liste2=p2.stdout.read().decode(errors='replace').split()
      for j in liste2:
          log.debug(j)
  except KeyboardInterrupt:
      raise
  except:
      log.warning('find returned errors')    
  liste_=[]
  for i in liste1:
      liste_.append(path.abspath(i))
  for i in liste2:
      liste_.append(path.normpath(cwd)+'/'+path.normpath(i))
  liste=uniq(liste_)
  #always exclude from this list/filename
  liste = exclude(liste,homedirexcludelistfilename)
  liste.append('/usr/local/portage/.git')
  liste.sort(key = lambda s: len(s),reverse=True)
  log.info("liste:")
  log.info("#####")
  for j in liste:
      log.info(j)
  return liste

def uniq(input):
  output = []
  for x in input:
    if x not in output:
      output.append(x)
  return output



def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description='update tool')
    parser.add_argument('-q', '--quick', type=int , metavar='days' ,action="store" ,help='speed up, by only processing dirs modified  more recently than now minus days (+/- 1 day)')
    return parser.parse_args()

def gitsuperpushpull2tmrl():
  args=parse_args()
  loop_go_on = True
  log.debug('starting loop')
  while loop_go_on:
    loop_go_on = False # stays false if nothing goes wrong
    log.debug('loop head')
    liste=generate_liste(quick=args.quick)
    for i in liste:
      if not args.quick is None:
        ## then quick -> need to see what happens.
        print('processing: '+i)
      else:
        ## not quick.
        log.info('processing: '+i)
      ## need path
      i=path.split(path.normpath(i))[0]
      ## do the item processing
      item_not_done = True
      while item_not_done:
           if not check_and_fix_some_stuff(i):
               log.error('failed to fix item: '+i)
               break
           while not check_pushpull(i):
               if ask_exclude(i):
                   break
                   break
               ask_terminal(i)
               try:
                   ask_rsync(i)
               except KeyboardInterrupt: raise
               except:
                   ask_create_remotepath(i)
                   ask_rsync(i)
           item_not_done = False # if the check_pushpull loop is terminated, either excluded or done.
  ## do some other stuff
  calendarsync()
  log.debug('done')

  
  """
run it
"""
gitsuperpushpull2tmrl()
