#!/usr/bin/python3
# Copyright 2018 Alexander Wilhelmi
# This file is part of gitsuperpushpull.
# 
# gitsuperpushpull is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# gitsuperpushpull is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with gitsuperpushpull.  If not, see <http://www.gnu.org/licenses/>.
# 
# Diese Datei ist Teil von gitsuperpushpull.
# 
# gitsuperpushpull ist Freie Software: Sie können es unter den Bedingungen
# der GNU General Public License, wie von der Free Software Foundation,
# Version 3 der Lizenz oder (nach Ihrer Wahl) jeder neueren
# veröffentlichten Version, weiter verteilen und/oder modifizieren.
# 
# gitsuperpushpull wird in der Hoffnung, dass es nützlich sein wird, aber
# OHNE JEDE GEWÄHRLEISTUNG, bereitgestellt; sogar ohne die implizite
# Gewährleistung der MARKTFÄHIGKEIT oder EIGNUNG FÜR EINEN BESTIMMTEN ZWECK.
# Siehe die GNU General Public License für weitere Details.
# 
# Sie sollten eine Kopie der GNU General Public License zusammen mit diesem
# Programm erhalten haben. Wenn nicht, siehe <https://www.gnu.org/licenses/>.
from subprocess import check_output,check_call,Popen,PIPE,DEVNULL,STDOUT,CalledProcessError,call
from os import path
from shlex import split,quote
import argparse
from sys import argv
from os import environ,getcwd
import neovim
import logging
generated_liste=False

def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description='update tool')
    parser.add_argument('-q', '--quick', type=int , metavar='days' ,action="store" ,help='speed up, by only processing dirs modified  more recently than now minus days (+/- 1 day)')
    parser.add_argument(      '--pim', action="store_true", default=False ,help='push pim')
    parser.add_argument(      '--portage',action="store_true", default=False , help='add portage dir to sync, needs --sync/-s')
    parser.add_argument('-t', '--ssh-target', action="store" ,help='string that defines the other host and that is configured for ssh like foo in "ssh foo"')
    parser.add_argument('-d', '--debug', action="store", default=logging.WARNING,type=int ,help='debug level 0-100, lower value means more debug messages, default is '+str(logging.WARNING)+'.')
    parser.add_argument(      '--search-path', action="store" ,help='call from git toplevel and specify path to search stuff')
    parser.add_argument('-u', '--url', action="store" ,help='url to use for submodule url generation')
    parser.add_argument('-f', '--file', action="store" , type=str,default=None, help='path to file with .git dirs listed')
    parser.add_argument('-a', '--urlpostfix', action="store" , default='.git' ,help='append url postfix')
    parser.add_argument('-r', '--remote-name', action="store" , default=None ,help='name of remote')
    parser.add_argument('-b', '--branch', action="store" , default=None ,type=str,help='name of branch or git ref to operate on')
    parser.add_argument('-p', '--push', action="store_true" ,help='push stuff, if no branch specified, all refs, except tags and the remote branches of the remote')
    parser.add_argument('-x', '--fix', action="store_true" ,help='fix more ask less')
    parser.add_argument('-n', '--non-interactive', action="store_true" ,help='non interactive')
    parser.add_argument('-v', '--verbose', action="store_true" ,help='be verbose')
    parser.add_argument('-s', '--shorten-remote-path', action="store_true" ,default=False,help='shortens path for remote like this: .config/nvim to .nvim')
    parser.add_argument(      '--remote-path-fix', action="store_true" , help="""Re-add all remotes. Specify list of .git dirs in file via --pathfile\nThe prog asks and shows a list of the commands.""")
    parser.add_argument('-m', '--submodule-fix', action="store_true" , help= """Removes from the index all path that has a .git dir and has no .git above them\nThen it uses 'git add submodule' to add the repo as submodule in that place.\nThe prog asks and shows a list of the commands.""")
    return parser.parse_args()

args=parse_args()

############     config   ###################################################################

excludelistfilename=".gitsuperpushpull_exclude"


if args.verbose or args.debug >= logging.INFO:
        LOGLEVEL=logging.INFO 
else:
        LOGLEVEL=args.debug

SHELLCMD_BASE = [ 'fish', '-c' ]
sshhost_string=args.ssh_target




############     logging     ###################################################################
try:
    log=logging.getLogger('root')
    log.handlers=[]
    log.setLevel(LOGLEVEL)
    handler=logging.StreamHandler()
    ## level for this handler
    handler.setLevel(LOGLEVEL)
    handler.setFormatter(logging.Formatter('%(asctime)s %(levelname)s %(funcName)s: %(message)s'))
    log.addHandler(handler)
except KeyboardInterrupt as e: raise e
except Exception as e: logging.info(e)

log.debug(excludelistfilename)

############   brain functions   ##########################################################################################

def gitsuperpush():
  global l_only_local
  global l_only_remote
  global l_both
  generate_liste()
  # local only stuff
  log.debug("processing local_only stuff...")
  for i in l_only_local:
          if remote_path_exists(i):
              log.debug("appending to both list")
              l_both.append(i)
          else:
              if check_fix_remote_git_dir_missing(i):
                   log.debug("appending to both list")
                   l_both.append(i)

  # remote only stuff
  log.debug("processing remote_only stuff...")
  for i in l_only_remote:
          if path.exists(i):
              log.debug("appending to both list")
              l_both.append(i)
          else:
              if check_fix_local_missing(i):
                   log.debug("appending to both list")
                   l_both.append(i)
          
  # process the ones that exist on both sides
  log.debug("processing local and remote exitsting .git dirs...")
  for dotgitdir in l_both:
    log.debug(dotgitdir)
    if not args.quick is None:
      log.debug("quick mode")
      # if quick -> need to see what happens.
      print('processing: '+dotgitdir)
    else:
      # not quick.
      log.debug("no quick mode")
      log.info('processing: '+dotgitdir)
    ## do the item processing
    process_entry(dotgitdir)
  log.debug('done')

def process_entry(dotgitdir):
    if not checkr_create_git_remote_entry(dotgitdir):
         log.error('remote entry missing and not fixed: '+dotgitdir)
    else:
        ## need path
        repopath = remove_trailing_somewhat_from_path(dotgitdir)
        retrycount=0
        while not (check_push(repopath) or retrycount == 10):
            retrycount = retrycount + 1
            if not offer_fixes(dotgitdir,checkr_create_git_remote_entry,dotgitdir):
                break


def check_fix_local_missing(i):
      log.debug("   "+i)
      m_e = "MISSING LOCAL GIT DIR: "+ i
      m_s = "FIXED MISSING LOCAL GIT DIR: "+ i
      m_f = "FAILED TO FIX MISSING LOCAL GIT DIR: "+ i
      if not args.fix:
          message(m_e)
      else:
          log.info(m_e)
      if args.fix:
          if check_init_local_git_dir(remove_trailing_somewhat_from_path(i)):
              if not args.fix:
                  MESSAGE(m_s)
              else:
                  log.info(m_s)
              return True
          else:
              log.error(m_f)
      else:
          if check_offer_fixes( i, check_ask_init_local_git_dir, path.exists ,([remove_trailing_somewhat_from_path(i)],None), ([i],None)):
              if not args.fix:
                  MESSAGE(m_s)
              else:
                  log.info(m_s)
              return True
          else:
              log.error(m_f)

def offer_fixes( dotgitdir, fix_function, *argl , **kwargs ):
    """
    If user does not want to fix return False else offer fix and return True.
    It doesn't matter whether the fix was successfull.
    """
    repopath = remove_trailing_somewhat_from_path(dotgitdir)
    if args.fix:
        inp='f'
    else:
        inp = input('(t)erminal/(e)xclude/(n)othing/(f)ix ? \n')
    if inp == 'e':
      append2excludefile(repopath,excludelistfilename)
      log.info("added to excludefile: "+str(dotgitdir))
      # faulty condition not fixed -> no sence to pushpull, return False
      log.debug("false")
      return False
    elif inp == 'n':
      # faulty condition not fixed -> no sence to pushpull, return False 
      log.debug("false")
      return False
    if inp == 't':
          terminal(repopath)
          return True
    if inp == 'f':
          fix_function( *argl, **kwargs )
          return True
    else:
        return False

def check_offer_fixes( dotgitdir, check_fix_function, check_function, fixfunction_args , checkfunction_args ):
        repopath = remove_trailing_somewhat_from_path(dotgitdir)
        if args.fix:
            inp='f'
        else:
            inp = input('(t)erminal/(e)xclude/(n)othing/(f)ix ? \n')
        if inp == 'e':
          append2excludefile(repopath,excludelistfilename)
          log.info("added to excludefile: "+str(dotgitdir))
          return False
        elif inp == 'n':
            return False
        elif inp == 't':
              terminal(repopath)
              return call_function( check_function, checkfunction_args )
        elif inp == 'f':
            if call_function(check_fix_function,fixfunction_args):
               return True
        else:
            return False


def call_function( function, args ):
    log.debug('calling function: '+ str(function))
    log.debug('with args: ' + str(args))
    if args[1] is not None:
        return function(*args[0],**args[1])
    else:
        return function(*args[0])
    

def check_fix_remote_git_dir_missing(i):
      log.debug("   "+i)
      m_e = "MISSING REMOTE GIT DIR: "+ i
      m_s = "FIXED MISSING REMOTE GIT DIR: "+ i
      m_f = "FAILED TO FIX MISSING REMOTE GIT DIR: "+ i
      if not args.fix:
          message(m_e)
      else:
          log.info(m_e)
      if args.fix:
          if check_init_remote_git_dir(remove_trailing_somewhat_from_path(i)):
              if not args.fix:
                  MESSAGE(m_s)
              else:
                  log.info(m_s)
              return True
          else:
              log.error(m_f)
              return False
      else:
          if check_offer_fixes( i, check_ask_init_remote_git_dir , remote_path_exists ,([remove_trailing_somewhat_from_path(i)],None), ([i],None)):
              if not args.fix:
                  MESSAGE(m_s)
              else:
                  log.info(m_s)
              return True
          else:
              log.error(m_f)
              return False



def check_git_remote_entry_name(dotgitdir):
  """
  checks for only the name of the entry,
  by useing 'git remote' without verbose options.
  """
  remotecmd='git remote'
  repopath=remove_trailing_somewhat_from_path(dotgitdir)
  log.debug('checking remote entry name in path: '+ repopath)
  fish_script=prepend_goto_dir_to_fishcode(remotecmd,repopath) 
  log.debug("running: "+ fish_script)
  o=None
  try:
      o = check_output_fish_shellscript(fish_script).decode().splitlines()
  except:
      log.error("CHECK FAILED somehow")
      log.error('output was :' + str(o))
      return False
  log.debug("output was: "+str(o))
  foundname=False
  for j in o:
      if not j.find(sshhost_string) is -1:
          foundname=True
  return foundname

def check_git_remote_entry_path(name, url, dotgitdir):
  """
  checks the url of git remote entry.
  by useing 'git remote -vv'
  returns (output,result)
  """
  remotecmd='git remote -vv'
  repopath=remove_trailing_somewhat_from_path(dotgitdir)
  log.debug('checking url of remote entry '+name+' in path: '+ repopath)
  fish_script=prepend_goto_dir_to_fishcode(remotecmd,repopath) 
  log.debug("running: "+ fish_script)
  try:
      o = check_output_fish_shellscript(fish_script).decode().splitlines()
  except:
      log.error("CHECK FAILED somehow")
      log.error('output was :' + str(o))
      return False
  log.debug("output was: "+str(o))
  foundurl=False
  for j in o:
      if j.find(name) == 0:
          log.debug("found name: "+ name)
          log.debug("searching for '"+url+"'"+" in : '"+j+"'" )
          if not j.find(url) is -1:
              log.debug("found '"+url+"'"+" in :"+j )
              foundurl=True
  return o,foundurl

def checkr_create_git_remote_entry(dotgitdir,check_remote=False):
  """
  Checks recursively if remote entry is existing and path is as expected.
  Offers fixes to the user.
  If returns true -> allright.
  """
  repopath = remove_trailing_somewhat_from_path(dotgitdir)
  foundname = check_git_remote_entry_name(dotgitdir)
  if not foundname:
    message("REMOTE ENTRY MISSING: local gitdir: "+dotgitdir)
    if args.fix:
        if check_create_git_remote_entry(repopath):
            # additional check
            return checkr_create_git_remote_entry(dotgitdir,check_remote=check_remote)
    else:
        if check_offer_fixes( dotgitdir,check_ask_create_git_remote_entry, checkr_create_git_remote_entry, ([repopath],None), ([dotgitdir],{"check_remote":check_remote}) ):
              # additional check
              return checkr_create_git_remote_entry(dotgitdir,check_remote=check_remote)
  if foundname:
      url=sshhost_string+':'+repopath
      o,remote_entry_ok = check_git_remote_entry_path( sshhost_string, url, dotgitdir )
      if not remote_entry_ok:
        log.info("remote entry wrong: git remote output: "+str(o))
        message("REMOTE ENTRY WRONG: local repopath: "+repopath)
        if args.fix:
            if  check_remove_git_remote_entry(repopath):
                # call again to recreate missing remote entry
                return checkr_create_git_remote_entry(dotgitdir,check_remote=check_remote)
        else:
            if check_offer_fixes( dotgitdir,check_ask_remove_git_remote_entry, checkr_create_git_remote_entry, ([repopath],None), ([dotgitdir],{"check_remote":check_remote}) ):
                #additional check
                return checkr_create_git_remote_entry(dotgitdir,check_remote=check_remote)
      else:
          # git 'remote entry' ok
          log.debug("true")
          return True


def check_push(repopath):
  """
  Do push. If not working rename branch to push to.
  Return whether succeeded.
  """
  log.debug(repopath)
  log.debug(args.branch)
  if args.branch is None:
      branches = get_branches( repopath )
  else:
      branches = [ args.branch ]
  log.debug(branches)
  for branch in branches:
    try:
        push_branch( repopath, branch )
    except PushFailed as e:
      log.info(e)
      text=e.errors
      f1 = text.find("does not appear to be a git repository")
      if f1 is not -1:
          ask_rsync_to_remote(repopath)
      log.info('PUSH FAILED for branch "'+branch+'"')
      return False
  return True



############   other functions   ##########################################################################################
class PushFailed(Exception):
    def __init__(self, message, errors):
        super().__init__(message)
        self.errors = ''
        text=''
        for i in errors:
          self.errors= self.errors + i.decode(errors='replace')
        log.debug(self.errors)

    

def push_branch(repopath,branch):
  """
  do push of branch. if not working rename branch to push to.
  """
  log.debug(repopath)
  log.debug(branch)
  pushcmdbase='gprh ' + sshhost_string
  log.log(19,'doing PUSH FOR BRANCH '+branch+' in dir '+repopath)
  # prepare
  log.debug("prepareing push...")
  pushcmd = pushcmdbase+' '+branch
  fish_script=prepend_goto_dir_to_fishcode(pushcmd,repopath)
  log.log(19,fish_script)
  # run
  log.debug("push...")
  pushcmd=pushcmdbase+' '+branch
  log.debug("here the script: "+ str(fish_script))
  log.info("push "+ args.ssh_target +" " + branch)
  try:
      p = Popen_fish_shellscript(fish_script)
      p.wait()
      stdout,stderr=p.communicate()
  except CalledProcessError:
      raise PushFailed( 'push failed: ret code: '+ str(p.returncode)+ '\n'+fish_script, [stdout]+[stderr] )
  log.debug(p.returncode)
  if p.returncode is not 0:
      raise PushFailed( 'push failed: ret code: '+ str(p.returncode)+ '\n'+fish_script, [stdout]+[stderr] )

def prepend_goto_dir_to_fishcode(code,dir_):
    log.debug('')
    quoted_dir = single_quote_it(dir_)  
    return "cd "+quoted_dir+"; and "+code


def single_quote_it(s):
    return "'"+s+"'"


def terminal(repopath):
  """
  """
  log.debug('')
  path=environ['NVIM_LISTEN_ADDRESS']
  nvim = neovim.attach('socket',path=path)
  win_id=nvim.call('win_getid')
  nvim.command('tabnew')
  fish_script=prepend_goto_dir_to_fishcode('echo ok',repopath)
  nvim.call('termopen',['fish', '-C', fish_script])
  nvim.command('tnoremap <buffer> <C-q> <C-\><C-n>:q<CR>:call win_gotoid('+str(win_id)+')<CR>i')
  message('>> press some key when done <<')
  input()


def ask_terminal(repopath):
  """
  """
  log.debug('')
  message('want terminal to fix? (y/n):')
  if input()=='y':
    path=environ['NVIM_LISTEN_ADDRESS']
    nvim = neovim.attach('socket',path=path)
    win_id=nvim.call('win_getid')
    nvim.command('tabnew')
    fish_script=prepend_goto_dir_to_fishcode('echo ok',repopath)
    nvim.call('termopen',['fish', '-C', fish_script])
    nvim.command('tnoremap <buffer> <C-q> <C-\><C-n>:q<CR>:call win_gotoid('+str(win_id)+')<CR>i')
    message('done? press enter or so')
    input('done? press enter or so')
    return True
  else:
      return False


def ask_rsync_to_remote(repopath):
  """
  offer some rsync cmd that copies the repo to remote
  """
  log.debug('')
  src         = repopath
  dest_       = remove_trailing_somewhat_from_path(repopath)+'/'
  dest        = sshhost_string+':'+dest_
  quoted_src  = single_quote_it(src)
  quoted_dest = single_quote_it(dest)
  fish_script = "rsync -auiv "+quoted_src+" "+quoted_dest 
  message('do fish-script: '+fish_script+' if yes , type uppercase yes: ')
  if input() == 'YES':
    is_exitcode_ok_fish_shellscript(fish_script)

def ask_rsync_from_remote(repopath):
  """
  offer some rsync cmd that copies the repo to remote
  """
  log.debug('')
  src_        = repopath
  dest        = remove_trailing_somewhat_from_path(repopath)+'/'
  src         = sshhost_string+':'+src_
  quoted_src  = single_quote_it(src)
  quoted_dest = single_quote_it(dest)
  fish_script = "rsync -auiv "+quoted_src+" "+quoted_dest 
  message('do fish-script: '+fish_script+' if yes , type uppercase yes: ')
  if input() == 'YES':
    is_exitcode_ok_fish_shellscript(fish_script)

def ask_create_remotepath(repopath):
    """
    Offer cmd to create remotepath.
    """
    base_cmd= 'mkdir -p'
    fish_script = base_cmd+' '+repopath
    ask_remote_fish_shell_script(fish_script,sshhost_string)

def ask_create_path(repopath):
    """
    Offer cmd to create remotepath.
    """
    base_cmd= 'mkdir -p'
    fish_script = base_cmd+' '+repopath
    ask_fish_shell_script(fish_script)

def remote_path_exists(p):
    log.debug(p)
    p_quoted=single_quote_it(p)
    fish_script='test -e '+p_quoted
    log.debug(fish_script)
    if is_exitcode_ok_remote_fish_shellscript(fish_script,sshhost_string)==0:
        return True
    else:
        return False


def ask_exclude(dotgitdir):
    log.debug('')
    message('exclude '+str(dotgitdir) +' ? (y/n)\n')
    inp = input()
    if inp == 'y':
      append2excludefile(remove_trailing_somewhat_from_path(dotgitdir),excludelistfilename)
      log.info('excluding: '+ dotgitdir)
      return True
    else:
      return False

def check_ask_create_git_remote_entry(repopath):
  """
  Add the remote entry to the the specified repo.
  """
  log.debug( "creating remote entry in : "+ repopath )
  gitaddremotecmd = "git remote add"
  git_remote_entry_name = sshhost_string
  git_remote_url_part0 = sshhost_string+":"
  git_remote_url = git_remote_url_part0+repopath
  quoted_git_remote_url = single_quote_it(git_remote_url)
  log.info( "ADDING REMOTE ENTRY to git repo: " + git_remote_url )
  log.info( "quoted git remote url : " + quoted_git_remote_url )
  fish_script_pre = gitaddremotecmd+' '+git_remote_entry_name+' '+quoted_git_remote_url
  fish_script = prepend_goto_dir_to_fishcode(fish_script_pre,repopath)
  message('do? answer y/n :\n'+str(fish_script)+'\n')
  inp = input()
  if inp=='y':
      log.debug('yes answered, running fish script')
      log.debug(fish_script)
      retcode = call_fish_shellscript(fish_script)
      log.debug(retcode)
      if retcode == 128 or retcode==0:  
          log.debug('true')
          return True
      else:
          log.debug('false')
          return False
  else:
      log.debug('false')
      return False


def check_create_git_remote_entry(repopath):
  """
  Add the remote entry to the the specified repo.
  """
  log.debug( "creating remote entry in : "+ repopath )
  gitaddremotecmd = "git remote add"
  git_remote_entry_name = sshhost_string
  git_remote_url_part0 = sshhost_string+":"
  git_remote_url = git_remote_url_part0+repopath
  quoted_git_remote_url = single_quote_it(git_remote_url)
  log.info( "ADDING REMOTE ENTRY to git repo: " + git_remote_url )
  log.info( "quoted git remote url : " + quoted_git_remote_url )
  fish_script_pre = gitaddremotecmd+' '+git_remote_entry_name+' '+quoted_git_remote_url
  fish_script = prepend_goto_dir_to_fishcode(fish_script_pre,repopath)
  inp = 'y'
  if inp=='y':
      log.debug('yes answered, running fish script')
      log.debug(fish_script)
      retcode = call_fish_shellscript(fish_script)
      log.debug(retcode)
      if retcode == 128 or retcode==0:  
          log.debug('true')
          return True
      else:
          log.debug('false')
          return False
  else:
      log.debug('false')
      return False

def check_ask_remove_git_remote_entry(repopath):
  """
  Remove a wrong remote entry from the the specified repo.
  """
  log.debug( "removing remote entry in : "+ repopath )
  gitrmremotecmd = "git remote remove"
  git_remote_entry_name = sshhost_string
  log.info( "REMOVING REMOTE ENTRY from git repo: " + git_remote_entry_name)
  fish_script_pre = gitrmremotecmd+' '+git_remote_entry_name
  fish_script = prepend_goto_dir_to_fishcode(fish_script_pre,repopath)
  message('Remove remote entry? answer y/n :')
  message(str(fish_script))
  inp = input()
  if inp=='y':
      log.debug('yes answered, running fish script')
      log.debug(fish_script)
      retcode = call_fish_shellscript(fish_script)
      log.debug(retcode)
      if retcode == 128 or retcode==0:  
          log.debug('true')
          return True
      else:
          log.debug('false')
          return False
  else:
      log.debug('false')
      return False

def check_remove_git_remote_entry(repopath):
  """
  Remove a wrong remote entry from the the specified repo.
  """
  log.debug( "removing remote entry in : "+ repopath )
  gitrmremotecmd = "git remote remove"
  git_remote_entry_name = sshhost_string
  log.info( "REMOVING REMOTE ENTRY from git repo: " + git_remote_entry_name)
  fish_script_pre = gitrmremotecmd+' '+git_remote_entry_name
  fish_script = prepend_goto_dir_to_fishcode(fish_script_pre,repopath)
  inp = 'y'
  if inp=='y':
      log.debug('yes answered, running fish script')
      log.debug(fish_script)
      retcode = call_fish_shellscript(fish_script)
      log.debug(retcode)
      if retcode == 128 or retcode==0:  
          log.debug('true')
          return True
      else:
          log.debug('false')
          return False
  else:
      log.debug('false')
      return False

def get_branches(repopath):
  '''
  returns list of branches in repopath dir
  '''
  branchcmd="git branch -a --format '%(refname)'"
  log.debug('entry')
  fish_script = prepend_goto_dir_to_fishcode(branchcmd,repopath)
  ll=[]
  log.debug('fish script: '+fish_script)
  l = check_output_fish_shellscript(fish_script).decode().splitlines()
  log.debug('fish script done')
  for i in l:
      if ( (i.find('/') is -1) or ((i.find('HEAD') is not -1 ) and ( i.find('losgelöst') is not -1) ) ):
          # means no refs/heads/branchname output
          # so no branch on this line
          pass
      elif path.split( i[len('refs/remotes/'):] )[1] == args.ssh_target:
          # these are the branches of the remote, dont include
          pass
      else:
          # not much stripping needed, cmd gives mostly clean output
          ll.append(i.strip())
  return ll

def calendarsync():
  log.debug('')
  """
  sync pimdir
  """
  log.debug('')
  is_exitcode_ok_fish_shellscript('calendarsync')


def generate_liste_local(quick=None,localpath=True):
    """
    gen list of git repos.
    One list of repos that exist on the local system.
    The repos are identified by there path.
    Not much is checked to verify them somehow.
    If some number to the quick keyword argument is given,
    then only modified repos are searched
    that has been modified within the count of days,
    that the quick parameter tells.
    """
    log.debug('list generation ...')

    # useing find to find em
    findcmdbase = 'find'
    if args.search_path is not None:
        findcmdbase=findcmdbase+' '+ args.search_path
    # using grep to get grep em
    grepcmd = "grep -E '/[.]git$'"

    cwd = getcwd() # get current workdir 

    if not quick is None:  # quick mode
        findtimeparam = '-mtime -'+str(quick)
        cmd           = findcmdbase+' '+findtimeparam+' | '+grepcmd
        cmd_remote    = prepend_goto_dir_to_fishcode(cmd,cwd)
        log.info("cmd for find em: " + cmd)
        log.info("cmd for find em on the remote system: "+ cmd_remote)
        message( 'MESSAGE: Processing only modified stuff, during last ' + str(quick) + ' * 24 h' )
    else:                  # no hurry mode, get em all 
        cmd           = findcmdbase + '|' + grepcmd
        cmd_remote    = prepend_goto_dir_to_fishcode( cmd, cwd )
        log.info("cmd for find em: " + cmd)
        log.info("cmd for find em on the remote system: "+ cmd_remote)
   
    #prepare the lists
    liste_local   = []
   
    #local scan
    try:    out = check_output_fish_shellscript( cmd )
    except  KeyboardInterrupt: raise # Feature: Interruptable
    except: 
            log.warning('LOCAL Find returned errors, something went wrong.' )    
            raise
    liste_local = out.decode( errors = 'replace' ).splitlines() 
    for j in liste_local:
        log.debug( 'found some  LOCAL-GIT-DIR : ' + j )
   
    # clean the found stuff
    if not localpath:
        ll  =  []
        for i in liste_local:
            ll.append(path.abspath(i))   
        liste_local  = ll
    
   
    # remove dupes
    liste=uniq(liste_local)
   
    
    liste.sort( key = lambda s: len(s),reverse=True)
   
    #log
    log.info("liste:")
    log.info("#####")
    for j in liste:
        log.info(j)
   
    return liste

def message(m):
    """
    prints message
    """
    mm = '#  '+ m +'  #'
    mm_len=len(mm)
    header_footer='#######################################################################################################################################################################################'
    print( header_footer[0:mm_len])
    print(mm)
    print( header_footer[0:mm_len])

def scan(quick=None,local=True,remote=True):

    # useing find to find em
    findcmdbase = 'find'
    
    # need proper search path
    if args.search_path is not None:
        search_path = args.search_path
    else:
        search_path = getcwd()

    findcmdbase = findcmdbase+' '+ search_path
    
    # using grep to get grep em
    grepcmd = "grep -E '/[.]git$'"


    if not quick is None:  # quick mode
        findtimeparam = '-mtime -'+str(quick)
        cmd           = findcmdbase+' '+findtimeparam+' | '+grepcmd
        cmd_remote    = prepend_goto_dir_to_fishcode( cmd, search_path )
        log.info("cmd for find em: " + cmd)
        log.info("cmd for find em on the remote system: "+ cmd_remote)
        message('MESSAGE: Processing only modified stuff, during last ' + str(quick) + ' * 24 h')
    else:                  # no hurry mode, get em all 
        cmd           = findcmdbase + '|' + grepcmd
        cmd_remote    = prepend_goto_dir_to_fishcode( cmd, search_path )
        log.info("cmd for find em: " + cmd)
        log.info("cmd for find em on the remote system: "+ cmd_remote)
   
    #prepare the lists
    if local:
        liste_local   = []
    else:
        liste_local = None
    if remote:
        liste_remote  = []
    else:
        liste_remote = None
    
    #local scan
    if local:
        try:    out = check_output_fish_shellscript( cmd )
        except  KeyboardInterrupt: raise # Feature: Interruptable
        except: 
                log.warning('LOCAL Find returned errors, something went wrong.' )    
                raise
        liste_local = out.decode( errors = 'replace' ).splitlines() 
        for j in liste_local:
            log.debug( 'found some  LOCAL-GIT-DIR : ' + j )
   
    #remote scan
    if remote:
        try:    out = check_output_remote_fish_shellscript( cmd_remote, sshhost_string )
        except  KeyboardInterrupt: raise
        except CalledProcessError:
            var0 = out.decode(errors="replace")
            log.debug(out)
            var1 = var0.find("Directory")
            if ( var0 is not -1) and (var0[var1:].find("does not exist") is not -1):
                log.debug("case to handle")
        except Exception as e:
            log.error('REMOTE find returned errors, something went wrong.' )
            log.error(e)
            log.error('remote cmd was: '+str(cmd_remote))
            log.error('sshhost_string was: '+str(sshhost_string))
            raise
        liste_remote = out.decode(errors='replace').splitlines()
        for j in liste_remote:
            log.debug( 'found some  REMOTE-GIT-DIR : ' + j )

    # add searchpath
    liste_remote = pathlist_add_searchpath( search_path , liste_remote )
    liste_local  = pathlist_add_searchpath( search_path , liste_local  )

    return liste_local,liste_remote

def path_add_searchpath( searchpath , p ):
    if not path.isabs(p):
        return path.abspath( path.normpath( searchpath ) + '/' + path.normpath( p ) )
    else:
        return path.normpath(p)

def pathlist_add_searchpath( search_path, l ):
    ll=[]
    for i in l:
        ll.append( path_add_searchpath( search_path, i ) )
    return ll 

def scan_file_and_include(filename):

    # need search path
    search_path = path.abspath( path.dirname( filename ))

    # read
    with open(filename,mode='rt') as f:
        lines = f.readlines()
    l=[]
    # strip newlines and empty space
    for i in lines:
        l.append(i.strip())
    lines=l
    
    # check for include statement prior to shell evaluation
    # and append scanned included files recursively
    # divide lines into 2 lists
    includelist=[]
    l=[]
    for line in lines:
        w = "include"
        if (line[0:len(w)]==w):
            # store rest of line and strip whitespace
            relpath=line[len(w):].strip()
            # append to list with searchpath prepended
            # so it will be a absolute path
            includelist.append( path_add_searchpath( search_path, relpath ))
        else:
            # if it is no include append to fresh include line free list
            # don't add searchpath yet, first shell expansion is needed 
            l.append(line)
    log.debug('len includelist:')
    log.debug(len( includelist ))
    log.debug('includelist:')
    log.debug(includelist)
    # scan all included files
    for f in includelist:
        l.extend( scan_file_and_include(f) )
    return l
         
def scan_file(filename):

    # need search path
    search_path = path.abspath( path.dirname( filename ))

    lines=scan_file_and_include( filename )
    
    # eval shell vars
    l=[]
    for line in lines:
        out=check_output_fish_shellscript('echo '+ line )
        l.append(out.decode(errors='replace').strip())
    lines=l
    # check for .git dir
    liste_local =[]
    liste_remote=[]
    for line in lines:
        dotgitpath = line + '/' + '.git'
        if path.exists( dotgitpath ):
            liste_local.append( dotgitpath )
        elif remote_path_exists( dotgitpath ):
            liste_remote.append( dotgitpath )
        else:
            # if path in line ends with .git
            # it works as repopath to push stuff
            p = path.normpath( line )
            if path.normpath( line )[-4:]=='.git':
                configpath = line + '/' + 'config'
                if path.exists( configpath ):
                    liste_local.append( p )
                elif remote_path_exists( configpath ):
                    liste_remote.append( p )
                else:
                    message( 'ERROR: path non existing, neither on remote nor local: '+ configpath )
            
    liste_remote = pathlist_add_searchpath( search_path , liste_remote )
    liste_local  = pathlist_add_searchpath( search_path , liste_local  )
    log.debug("liste_local:" )
    for i in liste_local:
        log.debug( i )
    log.debug("liste_remote:" )
    for i in liste_remote:
        log.debug( i )
    log.debug("returning")

    return liste_local,liste_remote

def generate_liste_3merge(quick=None):
    """
    gen 3 lists of git repos.
    One list of repos that exist only on the local system.
    One list of repos only remote system.
    One list of repos that exit on both systems.
    The repos are identified by their path.
    Not much is checked to verify them.
    If some number to the quick keyword argument is given,
    then only modified repos are searched
    that has been modified within the count of days,
    that the quick parameter tells.
    """
    log.debug('list generation ...')

    if args.file is None:
        # scan
        liste_local,liste_remote = scan(quick=quick,local=True,remote=True)
    else:
        # scan file entrys
        liste_local,liste_remote = scan_file(args.file)

    # remove dupes
    liste=uniq(liste_remote)
    liste=uniq(liste_local)
   
    # make 3 of em
    l_only_remote = []
    l_only_local  = []
    l_both        = [] 
    for i in liste_local:
        if i in liste_remote:
            l_both.append(i)
        else:
            l_only_local.append(i)
    for i in liste_remote:
        if i not in liste_local:
            l_only_remote.append(i)
   
    
    #exclude stuff if have no args.file
    if args.file is None:
        log.debug('############# start excluding #############')
        log.debug('local only ...')
        l_only_local = exclude(l_only_local)
        log.debug('remote only ...')
        l_only_remote = exclude(l_only_remote)
        log.debug('both ...')
        l_both = exclude(l_both)
        log.debug('############# end excluding #############')
   
    # extra dir
    if args.portage:
          l_both.append(environ.get('HOME')+'/code/portage/.git')
   
   
    l_both.sort(       key = lambda s: len(s),reverse=True)
    l_only_remote.sort(key = lambda s: len(s),reverse=True)
    l_only_local.sort( key = lambda s: len(s),reverse=True)
   
    #log
    log.info("liste:")
    log.info("#####")
    for j in l_only_local:
        log.debug("only locals:")
        log.info(j)
    for j in l_only_remote:
        log.debug("only remotes:")
        log.info(j)
    for j in l_both:
        log.debug("both:")
        log.info(j)
   
    return l_only_local, l_only_remote, l_both


def uniq(input):
  output = []
  for x in input:
    if x not in output:
      output.append(x)
  return output





def remove_trailing_somewhat_from_path(p):
    return path.split(path.normpath(p))[0]

def append_dotgit_to_path(p):
    return p+'/.git'

def is_exitcode_ok_remote_fish_shellscript(fish_script,sshhost_string, *args, **kwargs):
  """
  Uses ssh to check call a remote fishscript.
  """
  # ssh eats shell scripts.
  ssh_shell_script_aka_command = "fish -c "+quote(fish_script)

  # prepare the thing
  pythonish_sshcmd = [ 'ssh', sshhost_string , ssh_shell_script_aka_command  ]
  # and let it run
  return call(pythonish_sshcmd, *args, **kwargs)


def call_fish_shellscript(fish_script, *args, **kwargs):
  """
  check call a fishscript.
  """
  log.debug( fish_script)
  log.debug( args)
  log.debug( kwargs)
  # prepare the thing
  pythonish_cmd = [ 'fish', '-c' , fish_script  ]
  # and let it run
  return call(pythonish_cmd, *args, stderr=STDOUT, **kwargs)


def call_fish_shellscript_silent(fish_script, *args, **kwargs):
  """
  check call a fishscript.
  """
  log.debug( fish_script)
  log.debug( args)
  log.debug( kwargs)
  # prepare the thing
  pythonish_cmd = [ 'fish', '-c' , fish_script  ]
  # and let it run
  return call(pythonish_cmd, *args, **kwargs)

def check_except_fish_shellscript(fish_script, *args, **kwargs):
  """
  check a fishscript.
  """
  # prepare the thing
  pythonish_cmd = [ 'fish', '-c' , fish_script  ]
  # and let it run
  try:
      out = check_output(pythonish_cmd, *args, stderr=STDOUT, **kwargs)
      log.debug("running fish shellscript and check for exceptions: "+ str(fish_script))
      log.info(out.decode(errors='replace').strip('\n'))
  except KeyboardInterrupt: raise


def check_except_fish_shellscript_silent(fish_script, *args, **kwargs):
  """
  check a fishscript silent.
  """
  # prepare the thing
  pythonish_cmd = [ 'fish', '-c' , fish_script  ]
  # and let it run
  try:
      out = check_output(pythonish_cmd, *args, **kwargs)
      log.debug("running fish shellscript and check for exceptions: "+ str(fish_script))
      log.log(19,out.decode(errors='replace').strip('\n'))
  except KeyboardInterrupt: raise


def is_exitcode_ok_fish_shellscript(fish_script, *args, **kwargs):
  """
  check a fishscript.
  """
  # prepare the thing
  pythonish_cmd = [ 'fish', '-c' , fish_script  ]
  # and let it run
  try:
      out = check_output(pythonish_cmd, *args, stderr=STDOUT, **kwargs)
      log.debug("running fish shellscript and check for exceptions: "+ str(fish_script))
      log.info(out.decode(errors='replace').strip('\n'))
  except KeyboardInterrupt: raise
  except CalledProcessError as e:
     return False
  log.debug("No CalledProcessError returning True" )
  return True

def is_exitcode_ok_fish_shellscript_silent(fish_script, *args, **kwargs):
  """
  check a fishscript silent.
  """
  # prepare the thing
  pythonish_cmd = [ 'fish', '-c' , fish_script  ]
  # and let it run
  try:
      out = check_output(pythonish_cmd, *args, **kwargs)
      log.debug("running fish shellscript and check for exceptions: "+ str(fish_script))
      log.log(19,out.decode(errors='replace').strip('\n'))
  except KeyboardInterrupt: raise
  except CalledProcessError as e:
     return False
  log.debug("No CalledProcessError returning True" )
  return True


def Popen_fish_shellscript(fish_script, *args, **kwargs):
  """
  check_output a fishscript.
  """
  # prepare the thing
  pythonish_cmd = [ 'fish', '-c' , fish_script  ]
  # and let it run
  log.debug("running fish shellscript and return output: "+ str(fish_script))
  return Popen(pythonish_cmd, *args, stdout=PIPE, stderr=PIPE, shell=False, **kwargs)

def Popen_remote_fish_shellscript(fish_script, sshhost_string, *args,  **kwargs):
  """
  Uses ssh to check_output a remote fishscript.
  """
  # ssh eats shell scripts.
  ssh_shell_script_aka_command = "fish -c "+quote(fish_script)
  log.debug(ssh_shell_script_aka_command)

  # prepare the thing
  pythonish_sshcmd = [ 'ssh', sshhost_string , ssh_shell_script_aka_command ]
  # and let it run
  return Popen(pythonish_sshcmd, *args, shell=False, **kwargs)

def check_output_fish_shellscript(fish_script, stdout=PIPE, stderr=PIPE, *args, **kwargs):
  """
  check_output a fishscript.
  """
  # prepare the thing
  pythonish_cmd = [ 'fish', '-c' , fish_script  ]
  # and let it run
  log.debug("running fish shellscript and return output: "+ str(fish_script))
  return check_output(pythonish_cmd, *args, stderr=STDOUT, shell=False, **kwargs)

def check_output_remote_fish_shellscript(fish_script, sshhost_string, *args,  **kwargs):
  """
  Uses ssh to check_output a remote fishscript.
  """
  # ssh eats shell scripts.
  ssh_shell_script_aka_command = "fish -c "+quote(fish_script)
  log.debug(ssh_shell_script_aka_command)

  # prepare the thing
  pythonish_sshcmd = [ 'ssh', sshhost_string , ssh_shell_script_aka_command ]
  # and let it run
  return check_output(pythonish_sshcmd, *args, stderr=STDOUT, shell=False, **kwargs)

def ask_fish_shell_script(fish_script):
  message('do: '+fish_script+' ??? if yes , type yes:\n')
  if input() == 'yes':
    is_exitcode_ok_fish_shellscript(fish_script)

def ask_remote_fish_shell_script(fish_script,sshhost_string):
  message('do remote: '+fish_script+ '??? if yes , type yes:\n')
  if input() == 'yes':
    is_exitcode_ok_remote_fish_shellscript(fish_script,sshhost_string)
    

def clone2remote(dir_):
  try: 
    ask_rsync_to_remote(dir_)
  except:
    ask_create_remotepath(dir_)
    ask_rsync_to_remote(dir_)

def clone_from_remote(dir_):
  try: 
    ask_rsync_from_remote(dir_)
  except:
    ask_create_path(dir_)
    ask_rsync_from_remote(dir_)

def find_excludefilenames(localpath=True):
    # useing find to find em
    findcmdbase = 'find'
    if args.search_path is not None:
        findcmdbase=findcmdbase+' '+ args.search_path
    cmd=findcmdbase+' -type f -name ' + excludelistfilename
    
    #prepare the lists
    liste   = []
   
    #local scan
    try:    out = check_output_fish_shellscript( cmd )
    except  KeyboardInterrupt: raise # Feature: Interruptable
    except: 
            log.warning('LOCAL Find returned errors, something went wrong during exclude process. Check the exclude file.' )    
            raise
    liste = out.decode( errors = 'replace' ).splitlines() 
    for j in liste:
        log.debug( 'found some  EXCLUDEFILE : ' + j )
   
    # clean the found stuff
    if not localpath:
        ll  =  []
        for i in liste:
            ll.append(path.abspath(i)) 
        liste  = ll
   
    # remove dupes
    liste=uniq(liste)
    return liste


def exclude(liste_of_dotgitdir):

  """
  Excludes stuff from excludelistfilenames that are found inside the current workdir tree, from the list that will be processed.
  No Wildcards are allowed.
  Match with path to dotgitdir is needed. 
  Relative path is allowed.
  like so: "./bla/blabla/.git"
  or so  : "/home/foo/bar/.git"
  """
  ex_files=find_excludefilenames()
  log.debug('')
  removeliste=[]
  for k in ex_files: 
     if path.exists(k):
         dirname_=path.dirname(k)
         f=open(k,'rt')
         entrys = f.read().splitlines()
         f.close()
         for j in entrys:
             i=j.strip()
             if len(i) > 0:
               # no check, just append
               if path.isabs(i):
                   removeliste.append(path.normpath(i))
               else:
                  p2 = dirname_+'/'+i
                  abspath=path.abspath(path.normpath(p2))
                  removeliste.append( abspath )
  dotgitdirs=liste_of_dotgitdir
  log.debug('removeliste:'+str(removeliste))
  for r in removeliste:
      dotgitdirstoexclude = preprocess_exclude_entry(r)
      for dotgitdirtoexclude in dotgitdirstoexclude:
        if not dotgitdirtoexclude is None:
          for dotgitdiraround in dotgitdirs:
              if dotgitdiraround==dotgitdirtoexclude:
                  log.info( 'excluding: '+ dotgitdiraround)
                  dotgitdirs.remove( dotgitdiraround )
  log.debug('return:'+str(dotgitdirs))
  return dotgitdirs

def preprocess_exclude_entry(entry):
  """
  String comes in , list with absolute pathnames that are os.path.normcase or [], comes out.
  Find is used to find .gitdir that should be exluded. So entry needs to point at something.
  No Wildcards.
  """
  if not ( path.exists( entry) or remote_path_exists(entry)):
      return []
  p=path.abspath(path.normpath( entry ))
  if not path.basename(p) == '.git':
      # do a search for .git dirs
      ret_list = []
      for thing in find_dotgitdirs(p):
          ret_list.append( path.normpath( path.abspath( thing ) ) )
      return ret_list
  else:
      # already a .git path so return it as list with one element
      return [ p ]


def generate_liste():
    global  l_only_local
    global l_only_remote
    global l_both
    global generated_liste
    if generated_liste:
        return
    l_only_local, l_only_remote, l_both =  generate_liste_3merge(quick=args.quick)
    generated_liste=True
  

def find_dotgitdirs(p):
    """
    searches locally and remot for ".git" dirs inside of path
    """
    log.debug('searching for dotgitdir in "'+ p +'" ...')

    # useing find to find em
    findcmdbase = 'test -e '+p+';and find'
    if p is not None:
        findcmdbase=findcmdbase+' '+ p
    # using grep to grep em
    grepcmd = "grep -E '/[.]git$'"

    cwd = getcwd() # get current workdir 

    cmd           = findcmdbase + '|' + grepcmd
    cmd_remote    = prepend_goto_dir_to_fishcode( cmd, cwd )
    log.info("cmd for find em: " + cmd)
    log.info("cmd for find em on the remote system: "+ cmd_remote)
   
    #prepare the lists
    liste_local   = []
    liste_remote  = []
   
    #local scan
    out=''.encode()
    try:    out = check_output_fish_shellscript( cmd )
    except  KeyboardInterrupt: raise # Feature: Interruptable
    except Exception as e: 
            log.warning('LOCAL Find returned errors, something went wrong.' )
            log.warning(e)
            pass
    liste_local = out.decode( errors = 'replace' ).splitlines() 
    for j in liste_local:
        log.debug( 'found some local git dir : ' + j )
   
    #remote scan
    try:    out = check_output_remote_fish_shellscript( cmd_remote, sshhost_string )
    except  KeyboardInterrupt: raise
    except CalledProcessError:
        var0 = out.decode(errors="replace")
        log.debug(out)
        var1 = var0.find("Directory")
        if ( var0 is not -1) and (var0[var1:].find("does not exist") is not -1):
            log.debug("case to handle")
    except:
        log.warning('REMOTE find returned errors, something went wrong.' )    
        raise
    liste_remote = out.decode(errors='replace').splitlines()
    for j in liste_remote:
        log.debug( 'found some remote git dir : ' + j )

    # return concatenated list
    return liste_remote+liste_local



def append2excludefile(repopath,excludelistfilename):
  log.debug('')
  f=open(excludelistfilename,'at')
  f.write('\n')
  f.write(append_dotgit_to_path(repopath))
  f.close()

def check_init_remote_git_dir(d):
    fishshellscript="git init "+d
    log.info('INIT REMOTE: '+fishshellscript)
    if is_exitcode_ok_remote_fish_shellscript(fishshellscript,sshhost_string):
        log.debug('true')
        return True
    else:
        log.debug('false')
        return False

def check_ask_init_remote_git_dir(d):
    fishshellscript="git init "+d
    message('do remote: (y/n) ?:\n'+fishshellscript+'\n')
    if input() == "y":
        if is_exitcode_ok_remote_fish_shellscript(fishshellscript,sshhost_string):
            return True
        else:
            return False
    else:
        return False


def check_ask_init_local_git_dir(d):
    fishshellscript="git init "+d
    message('do local: (y/n) ?:\n'+fishshellscript+'\n')
    if input() == "y":
        if is_exitcode_ok_fish_shellscript( fishshellscript):
            return True
        else:
            return False
    else:
        return False

def check_init_local_git_dir(d):
    fishshellscript="git init "+d
    log.info('INIT LOCAL: ' + fishshellscript)
    if is_exitcode_ok_fish_shellscript( fishshellscript ):
            return True
    else:
            return False

def is_debugging_on():
    if LOGLEVEL == logging.DEBUG:
        return True
    else:
        return False


def gen_repopath_liste():
    """
    returns all the path of all the .git repos
    """
    repo_path_liste=[]
    l = generate_liste_local()
    if len(l) == 0:
        log.info("nothing found")
        exit(1)
    for i in l:
      repo_path_liste.append(remove_trailing_somewhat_from_path(i))
    return repo_path_liste

def read_path_file(fn):
    """
    returns all the path in the path file
    """
    repo_path_liste=[]
    l=[]
    with open(fn,mode='rt') as f:
        for line in f.readlines():
             ap=line.strip()
             if not len(ap) == 0:
                  l.append(line.strip())
    return l
   
def prepare_path_liste(liste):
    """
    returns (['pat_component','path_component',...],'path_as_string')
    """
    l=[]
    for i in liste:
        p=path.normpath(i)
        pp=[]
        while True:
            sp=path.split(p)
            pp.append(sp[1])
            p=sp[0]
            if sp[0]=='':
                break
        # reverse sort it
        rpp=[]
        for i in range(len(pp)-1, -1 , -1):
             rpp.append(pp[i])
        l.append(rpp)
    #convert to string
    ll=[]
    for i in l:
         s='/'
         for j in i:
             s=s+j+'/'
         ll.append( ( i, s.strip('/') ) )   # tuple with list and string
    return ll

def clean_prepared_liste(prepared_list):
    """
    Removes stuff that is not useful for submodule fixing.
    Removes pathes from the prepared list that are probably a git subrepo of another path.
    And the path ./.git is removed because this is probably the repo to fix, itself.
    Rest is done by checking if one of them is contained in another one and removeing the longer one.
    """
    kk=prepared_list.copy()
    remove=[]
    sl='/'
    for i in prepared_list:
        for j in kk:
            if not j[1] == i[1]:            # second thing is the string to compare
                # need slash in front and back !  example dir : '.' would not work
                r1 = ( sl+j[1]+sl ).find( sl+i[1]+sl ) 
                r2 = ( sl+i[1]+sl ).find( sl+j[1]+sl )
                if r1 is not -1 or r2 is not -1:
                    # one is part of the other -> remove the longer one because it is probably a subrepo of the shorter one
                    #print(j[1]+'   <-->   '+i[1])
                    if   len(j[1]) > len(i[1]):
                        remove.append(j)      # append to removelist the whole thing
                    elif len(j[1]) < len(i[1]):
                        remove.append(i)
                    else:
                         raise Exception('error, unexpected case')
    ## remove dupes
    remove=uniq(remove)
    ## remove thema
    for i in remove:
        log.info("removing: "+str(i))
        prepared_list.remove(i)
    # remove the "." dir
    try:
        (prepared_list.remove((['.'],'.')))
    except ValueError:
        pass
    return prepared_list


def __shorten_path(p):
    """
    shortens the path like this: .config/nvim to .nvim
    if not start with dot, don't prepends the dot
    """
    pp = path.split( path.normpath(p) )
    # p starts with . and path has a slash '/'
    if p[0] == '.' and len(pp[0]) > 0 :
        return "." + pp[-1] # return last component with '.' prepended
    elif len(pp[0]) > 0:
        return  pp[-1]     # return last component
    else:
        return p       # return original path

def __make_url(  local_path , url=None , shorten_remote_path=True ,urlpostfix=""):
    if url is None:
        return './' + local_path
    else:
        #from validators import url as is_valid_url
        if True:
            if url[-1]=='/':
                url=url[0:-2]
            if shorten_remote_path:
                return url + '/' + __shorten_path(local_path) + urlpostfix
            else:
                return url + '/' + path.normpath(local_path) + urlpostfix
        else:
            raise Exception('url invalid')
    
    
def submodule_fix(url=None,pathfile=None, shorten_remote_path=True,urlpostfix=""):
    if not pathfile==None:
        l=read_path_file( pathfile )
    else:
        l=prepare_path_liste( gen_repopath_liste() )
    
    l=clean_prepared_liste(l)
    
    cmdliste=[]
    for i in l:
           log.debug(i)
           i_url = __make_url(local_path=i[1] , url=url,  shorten_remote_path=shorten_remote_path , urlpostfix=urlpostfix)
           path = './' + i[1] 
           cmd='git submodule add ' + i_url + ' ' + path
           cmd2='git rm --cached -r ' + path
           cmdliste.append(cmd2)
           cmdliste.append(cmd)
    
    for i in cmdliste:
        print(i)
    
    print()
    if input('apply cmds? If yes type uppercase yes: ')=='YES':
        for i in cmdliste:
            call_fish_shellscript(i)

def remote_path_fix(remotename,url=None,pathfile=None, shorten_remote_path=False,urlpostfix=""):
    if not pathfile==None:
        l=read_path_file(pathfile)
    else:
        l=prepare_path_liste( gen_repopath_liste() )
    #for i in l:
    #    print(i)
    
    l=clean_prepared_liste(l)
    #for i in l:
    #    print(i)
    
    cmdliste=[]
    for i in l:
           log.debug(i)
           i_url = __make_url(local_path=i , url=url,  shorten_remote_path=shorten_remote_path , urlpostfix=urlpostfix)
           p = './' + i[1] 
           cmd='cd '+path.abspath(p) +' ;set -e GIT_DIR;set -e GIT_WORK_TREE; git remote rm ' + remotename
           cmd2='cd '+path.abspath(p)+' ;set -e GIT_DIR;set -e GIT_WORK_TREE; git remote add ' + remotename + ' '+ i_url
           cmdliste.append(cmd)
           cmdliste.append(cmd2)
    
    for i in cmdliste:
        print(i)
    
    print()
    if input('apply cmds? If yes type uppercase yes: ')=='YES':
        for i in cmdliste:
            call_fish_shellscript(i)
   

#########################  main  ###################################################
    
# clean env
try:
    environ.pop('GIT_DIR')
    environ.pop('GIT_WORK_TREE')
except KeyError:
    pass

"""
run it
"""

if args.submodule_fix:
    submodule_fix(url=args.url,urlpostfix=args.urlpostfix,pathfile=args.file,shorten_remote_path=args.shorten_remote_path)
if args.remote_path_fix:
    remote_path_fix(args.remote_name,url=args.url,urlpostfix=args.urlpostfix,pathfile=args.file ,shorten_remote_path=args.shorten_remote_path)
if args.push or args.portage:
    gitsuperpush()
if args.pim:
    ## do some other stuff
    calendarsync()
